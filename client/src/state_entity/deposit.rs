

// deposit() messages:
// 0. 2P-ECDSA to gen shared key P
// 1. user sends funding tx outpoint, B1, C1
// 2. Co-op sign kick-off tx (generated by SE)
// 3. Co-op sign back-up tx (generated by user)

use bitcoin;
use bitcoin::blockdata::transaction::{ TxIn, OutPoint };
use bitcoin::util::amount::Amount;
use bitcoin::secp256k1::Signature;
use bitcoin::hashes::sha256d;
use bitcoin::util::bip143::SighashComponents;
use curv::elliptic::curves::traits::ECPoint;
use curv::BigInt;
use curv::arithmetic::traits::Converter;

use crate::wallet::to_bitcoin_public_key;
use crate::ClientShim;
use crate::ecdsa;
use crate::state_entity::util::{ build_tx_0, build_tx_k,
    NETWORK, RBF };

use super::super::utilities::requests;
use super::super::wallet::Wallet;
use hex;
use uuid::Uuid;
use std::collections::HashMap;


const PATH_PRE: &str = "deposit";

#[derive(Serialize, Deserialize)]
pub struct DepositMessage1 {
    outpoint: OutPoint,
    backup_pubkey: String,
    proof_pubkey: String
}

pub fn deposit(client_shim: &ClientShim) ->(String, String) {
    // 2P-ECDSA
    let private_share: ecdsa::PrivateShare = ecdsa::get_master_key(client_shim);
    println!("{}",private_share.id);
    println!("{:?}",private_share.master_key.public);

    // make wallet
    let id = Uuid::new_v4().to_string();
    let last_derived_pos = 0;
    let addresses_derivation_map = HashMap::new();
    let network = "regtest".to_string();
    let mut wallet = Wallet {
        id,
        network,
        private_share,
        last_derived_pos,
        addresses_derivation_map,
    };

    // make funding tx
    let addr = wallet.get_new_bitcoin_address();
    let inputs =  vec![
        TxIn {
            previous_output: OutPoint { txid: sha256d::Hash::default(), vout: 0 },
            sequence: RBF,
            witness: Vec::new(),
            script_sig: bitcoin::Script::default(),
        }
    ];
    let amount = Amount::ONE_BTC;
    let tx_0 = build_tx_0(&inputs, &addr, &amount).unwrap();
    println!("tx_O: {:?}",tx_0);

    // first message
    let deposit_first_msg = DepositMessage1{
        outpoint: OutPoint::new(tx_0.txid(),0),
        backup_pubkey: String::from("backup_pubkey"),
        proof_pubkey: String::from("proof_pubkey")
    };

    let resp: (String, String) =
        requests::postb(client_shim, &format!("{}/{}/first", PATH_PRE, wallet.private_share.id),&deposit_first_msg).unwrap();

    // make kick-off tx
    let mut tx_k = build_tx_k(&inputs.get(0).unwrap(), &addr, &amount).unwrap();

    println!("tx_k: {:?}",tx_k);

    let address_derivation = wallet
        .addresses_derivation_map
        .get(&addr.to_string())
        .unwrap();

    let mk = &address_derivation.mk;
    let pk = mk.public.q.get_element();

    let comp = SighashComponents::new(&tx_k);
    let sig_hash = comp.sighash_all(
        &tx_k.input[0],
        &bitcoin::Address::p2pkh(
            &to_bitcoin_public_key(pk),
            NETWORK).script_pubkey(),
        amount.as_sat(),
    );

    println!("addr: {}",addr);

    let signature = ecdsa::sign(
        client_shim,
        BigInt::from_hex(&hex::encode(&sig_hash[..])),
        &mk,
        BigInt::from(0),
        BigInt::from(address_derivation.pos),
        &wallet.private_share.id,
    ).unwrap();

    let mut v = BigInt::to_vec(&signature.r);
    v.extend(BigInt::to_vec(&signature.s));

    let mut sig_vec = Signature::from_compact(&v[..])
        .unwrap()
        .serialize_der()
        .to_vec();
    sig_vec.push(01);

    let pk_vec = pk.serialize().to_vec();

    tx_k.input[0].witness = vec![sig_vec, pk_vec];
    println!("tx_k: {:?}",tx_k);


    return resp;
}
