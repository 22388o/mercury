//! state_entity
//!
//! State Entity implementation

use rocket_contrib::json::Json;

use crate::storage::se_mock::{ StateChain, MockStorage };

/// State struct representing an active UTXO shared by state entity and Owner
#[allow(dead_code)]
pub struct State {
    id: u32,
    utxo: String,
    key: String,
    state_chain: StateChain
    // owner_auth:
}
/// State Entity main
pub struct StateEntity {
    /// storage
    pub storage: MockStorage
}

// deposit() messages:
// 1. 2P-ECDSA to gen shared key P
// 2. user sends funding tx outpoint, B1, C1
// 3. Co-op sign kick-off tx (generated by SE)
// 3. Co-op sign back-up tx (generated by user)

#[post("/deposit/first", format = "json")]
pub fn deposit_first() -> Result<Json<(String,String)>,()>{
    Ok(Json((String::from("deposit"),String::from("first"))))
}





#[cfg(test)]
mod tests {
    // Mock Owner can be used to implement and test client side of protocol
    use bitcoin::util;
    use crate::util::generate_keypair;
    /// public/private key pairs.
    #[allow(dead_code)]
    pub struct KeyPair {
        priv_key: util::key::PrivateKey,
        pub_key: util::key::PublicKey
    }
    impl KeyPair {
        /// generate random key pair
        pub fn new() -> Self {
            let key_pair = generate_keypair();
            KeyPair{ priv_key: key_pair.0, pub_key: key_pair.1 }
        }
    }
    /// Rpc implementation of Owner
    #[allow(dead_code)]
    pub struct MockOwner {
        /// Rpc client instance
        id: u32,
        /// Keys
        keys: Vec<KeyPair>
    }
    impl MockOwner {
        /// Init with single key
        pub fn new() -> Self {
            MockOwner{ id: 1, keys: vec![KeyPair::new()] }
        }
        /// generate new key and add to self.keys
        pub fn new_key(&mut self) {
            let key_pair = generate_keypair();
            self.keys.push(KeyPair{ priv_key: key_pair.0, pub_key: key_pair.1 })
        }
    }


}
